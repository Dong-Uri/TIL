(정리 도움받음)

#1

좋은 웹 ap의 조건

성능: 빠를수록 좋다 (캐싱, 비동기 처리, 요청 시간) -> 외부 Rest API 비동기호출, synchronous, asynchronose
안정성: 요청 정상 처리 및 사고 방지
보안: 보안 스펙트럼이 넓으니 주요 동작에 대한 이해 필요
보안 관련 고려사항

클라이언트가 아닌 서버 중심의 로직 처리 (클라이언트 요청은 쉽게 변경 가능)
사용자 인증&인가 (사용자 인증 없는 요청 처리는 다양한 접근 경로 존재)
사용자 요청의 유효성 (서버) 검증 (요청 필드 값 유효 검증, 리소스 변경 건은 철저하게 진행) -> 요청 길이 코드 부합성 검사는 성능에도 도움이 된다
sql injection, XSS(Cross-Site Sctipting) 방어 (클라이언트 입력 값은 WHERE 조건문의 일부로 사용하는 경우, script 태그를 사용하는 경우)
보통 http 요청의 첫 진입점으로 ngnix를 쓰는데 Dos 공격 방지 등 최소한의 장치 마련

부하 테스트(필수)

N개의 클라이언트 요청
적절한 응답 시간과 데이터 신뢰성
JMeter 등의 도구 활용
데이터 신뢰성

concurrency 이슈
단일/멀티 서버
트랜잭션 처리
암호화: 갈취당하더라도 쓸 수 없도록 하는 것이 핵심, 솔루션 자체도 인가 제품 사용
https 통신 필수
로깅

logger 이용
이슈 추적의 시작
서버 테스트

서버 테스트 시나리오
서버 프로그래밍

너를 의심 : 서버 중심 로직 처리, 유효성 검증, 사용자 인증/인가, 해킹 방어
나를 의심 : 응답 시간, 신뢰성, 트랜잭션, 리소스 권한, 암호화
발생한 일 기록 : 로깅

#2

Back-End : 웹 서버 프로그래밍 시 주의할점
좋은 사진이 담길 것 같은 카메라?
전문가용 DSLR 카메라
전문가용 필름 카메라
스마트폰 카메라
좋은 사진이 갖춰야 할 것들
균형

색감

이야기

있으면 좋은 것들
전문가용 고성능 카메라

작가의 장비 활용 스킬

좋은 웹 AP가 가져야 할 것들
성능

안정(신뢰)성

보안

웹 AP가치 척도 - 성능
온전히 작동한다면 빠르면 빠를수록 좋지 않을까?

사용자 http요청에 대한 응답 시간을 줄여주자

기능 요건에 맞춰 적절히 비동기 처리 여부를 정해보자

쓰기보다 읽기가 많은 데이터라면 캐싱을 적극 고려해보자

웹 AP 가치 척도 - 안정성
아무리 빠르더라도 제품에 하자가 있다면 사용 불가

일반적으로 속도보다 우선하는 가치

빗발치는 요청을 정상적으로 처리 할 수 있어야 함

데이터가 틀어지거나 서비스 불능 등의 사고는 반드시 막아야 함

웹 AP 가치 척도 - 보안
빠르면서 안정적이더라도 안전하지 않다면 매우 심각한 문제

보안 분야 스펙트럼은 굉장히 넓어 모든 내용을 섭렵하기란 불가능에 가까움

‘웹’관련 보안에 관심을 기울이는 노력은 필요함

사용자 요청부터 서버에 이르기까지 주요 제품 및 동작에 관한 기본 이해가 있어야만 보안의 기초를 열 수 있음

뛰어난 역량의 웹 서버 개발자?
최신 웹 프레임워크 사용 경험만으로는 알 수 없음

성능, 안정성, 보안과 같은 핵심 가치에 대한 이해도가 높음

최신 제품이 위의 핵심 가치를 추구하는데에 유리한면은 많음

싱글 게임
개발자는 language를 사용해 궁극적으로 메모리 에 저장되는 값을 제어해가며 원하는 기능을 만들어 나간다

프로세스에서 사용하고 있는 메모리에 담긴 값을 쉽게 수정 가능

온라인 게임 서버
싱글 게임과는 달리 유저로부터 생성되는 데이터는 서버를 통해 관리됨

여러 유저들의 정보가 공정하게 관리되어야 함

온라인 게임
클라이언트의 데이터 VS 서버가 알고 있는 데이터

뭐가 우선일까? 이유는?

클라이언트 입장에서 메모리를 바꾸는 것은 할 수도 있는 일이다. 상대적으로

2개의 데이터 중 서버쪽을 더욱 우선시해야 할 것이다.

서버쪽에서 나름의 논리를 바탕으로 위조/변조에 대해 검증하는 로직이 있어야 할 것이다.

클라이언트 의심의 중요성

클라이언트?
서버 중심의 능동적인 대처 필요

클라이언트를 믿는다고?

‘너’를 의심(사용자 의심)
사용자 인증 & 인가

서버 중심의 견고한 로직 처리

사용자 요청의 유효성 검증

Sql injection, XSS 방어

HTTP
Hyper Text Transfer Protocol

Stateless

HTTP서버는 불특정 다수의 요청을 전제

사용자 인증 & 인가
복잡하고 긴 URL을 암호처럼 사용?

장소를 알더라도 사용자는 허가를 받고 진입 할 수 있어야 함

사진첩의 ‘사진’들은 비공개 데이터가 다수

긴 url만 알고 있다면 그대로 접근 가능했던 시절이 있었음

물론 의도한 기능이라면 사용자에게 위임 가능함

사용자 인증 & 인가 - worst 사례
최초 로그인을 통한 인증 과정 이후 차후 서비스 구동에 필요한 모든 API 호출은 URL이 곧 암호인 것 처럼 사용

셋탑 박스 내부에서 호출하는 것이라 일반 고객들은 URL을 알 수 없다는 가정하에 진행한 무모한 사례

서버 중심의 견고한 로직 처리
웹 브라우저에서 관리되는 가격 데이터 수정은 어렵지 않음

네트워크를 통한 http요청 데이터에서의 가격 데이터 변경도 충분히 변조 가능

어렵지 않게 조작한 화면에 노출된 가격으로 결제 프로세스를 태운다? - 쇼핑몰 물품 결제 값 조작

클라이언트 요청은 쉽게 변경 가능
주문 버튼 클릭 후 PG사로 주문ID와 결제 금액을 전송

PG사는 요청 받은 변조된 금액 20,000원 정상 결제 처리

PG사를 통해 쇼핑몰은 해당 주문 ID건이 정상 결제되었다는 응답을 받고 배송 시작

PG사로부터 받은 http 메세지 만으로 모든 정보를 확신 할 수 있어야 함

최소한 결제 금액 정보를 함께 받았어야 했음

혹은 결제 확정 전 PG사에 결제 금액 정보를 확인하는 과정을 추가했어야 함

요청 검증
요청 필드 값들이 유효한지 서버에서도 검증

특히 리소스 변경에 대한 건은 철저하게 진행

요청 값들의 길이, 코드 부합성등을 체크하는게 오히려 성능에도 도움이 될 수 있음

요청 검증 - 파일 업로드 worst 사례
모 카드사 > jsp로 구현된 서비스 > 게시판 파일 업로드 기능 중

‘.jsp’ 파일 그대로 업로드 허용

‘.jsp’ 소스 파일 내에 특정 테이블 조회 기능 구현

카드 고객의 주요 정보 탈취

SQL injection
클라이언트의 입력 값은 DB query > where 조건문의 일부로 사용

select _ from USERS where id='user1' and pw = 'pw1';
select _ from USERS where id = '' or 1 = 1 --' and pw = 'pw1';
XSS 방어
프레임워크(생태계)마다 활용되는 제품들은 있다

만약 없다면 스크립트 실행이 가능한 구문들을 직접 필터링하자

‘나’를 의심(서버)
동시간대 1이 아닌 N개 클라이언트 요청

적절한 응답 시간과 데이터 신뢰성

트랜잭션 처리

서비스 및 컨텐츠 사용 권한 제어

주요 데이터 암호화

부하 테스트
1이 아닌 N개의 클라이언트의 요청

적절한 응답 시간과 데이터 신뢰성

‘JMeter’등의 도구를 활용해 부하 테스트 수행

서버 포지션을 목표로 한다면 선택이 아닌 필수

응답 시간
요청 - 응답 시간을 줄이기 위해 캐시 layer 적용 고려

EHCACHE, redis, MEMCACHED

응답 시간 - 무인 주차 정산 시스테 구현
입차시 할인을 위한 유공자, 저공해 차량 여부 체크를 위한 2개의 오부 서비스 콜이 있다고 가정

각 서비스 응답 시간은 평균 5초

① 카메라 차량 번호판 인식 -0.2초
② 유공자여부*외부RESTAPI*호출 - 5초
③ 경차여부*외부RESTAPI*호출 - 5초
④할인 정보 포함 입차 정보 DB 저장 - 0.1초
⑤ 차단기 올라감 & 통 -0.3초

② ) 유공자여부*외부RESTAPI*호출 - 5초
③ 경차여부*외부RESTAPI*호출 - 5초
->
② 유공자여부*외부RESTAPI*비동키호출 -0.01초
③ 경차여부*외부RESTAPI*비동기호출 -0.01초
① 카메라 차량 번호판 인식 -0.2초
② 할인 정보 제외 입차 정보 DB 저장 -0.1초
③유공자여부*외부RESTAPI*비동기호출 - 0.01초
④ 경차여부*외부RESTAPI*비동기호출 - 0.01초
⑤ 차단기 올라감 & 통과 - 0.3초

⑥가까운 미래에 할인 정보 DB 업데이트 - 호출 후 대략 10초 후 0.1초 소요

응답 시간 - 비동기 처리
동기/ 비동기는 중요한 개넘

업무 이해에 기반한 적절한 비동기 처리

사용 언어, 프레임워크 환경에서 제공하는 것 부터 적용해보자

데이터 신뢰성 - 관리자 환경 설정 예제
관리자 환경설정 내용을 '로컬 파일'로 관리

changeEnv(){
파일오픈 "D:Wenv₩env.conf"
write 작업 수행
}
예상 이슈와 해결방안은?

데이터 신뢰성 - 싱글 서버?
단일 서버로 서비스 하는 경우는 매우 드물다

해당 머신의 로컬 스토리지에 파일을 저장했다면 다른 머신에서의 데이터 신뢰성은 깨짐

데이터 신뢰성
멀티 스레드 환경에서의 concurrency 이슈

Thread-safe VS Thread-unsafe 활용 제품(라이브러리)의 설명에 주목

트랜잭션 처리 - 결제 예제
쇼핑몰의 결제는 복수 개 수단으로 진행

문화상품권 + 신용카드 + 쇼핑몰 포인트 3개의 수단을 지원한다고 할 때 하나가 실패하더라도 전체 결제 트랜젝션 실패

암호화
평문을 암호화 하는 작업에는 분명 연산에 따른 비용이 수반됨

DB의 USER 테이블에 주민번호, 핸드폰 번호와 같은 개인정보들 → 반드시 암호화해서 컬럼에 넣어줘야 하는 걸까?

잠깐! 개발자가 하는 일이란?
개발자가 하는 일 이란게 뭐 있나요?

돌려보고 생각대로 안 움직이면 디버깅 걸고 한 줄 한 줄 확인하고 사용하는 라이브러리(제품)가 있다면 로그 잘 보고 하나씩 하나 씩 해결 하는 것 말고 뭐 있나요?

logging
서버가 작동하면서 발생하는 주요 이슈들을 기록

단순 콘솔 출력보다는 주요 logger(라이브러리)를 사용

서버 운영 시 발생한 이슈 추적의 시작점

서버 프로그래밍
'너'를 의심
•서버 중심의 로직 처리
•요청값들의 유효성 검증
•사용자 인증 및 인가
•Sql injection, XSS 방어

'나'를 의심
•적절한 응답 시간
•데이터 신뢰성
•트랜잭션 처리 여부
•리소스 사용 권한 체크
•주요 데이터 암호

발생한 일 기록
•효율적인 logging 구축
•주요 액티비티 로깅
•익셉션, 에러 로깅
