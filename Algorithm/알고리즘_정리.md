- 정렬(Sort)

  - O(n^2)

    - 버블정렬(Bubble)

      - 인접한 두 데이터의 크기를 비교해서 정렬

    - 선택정렬(Selection)

      - 데이터 중 최소값을 찾아 순서대로 정렬

    - 삽입정렬(Insertion)

      - 한 데이터를 기준으로 해당 데이터의 앞 쪽에 위치한 데이터와 비교
      - 더 작은 값을 찾을 때까지 데이터를 뒤로 밀어냄
      - 삽입된 데이터보다 작은 데이터를 만날 때까지 반복
      - 없는 경우 0번 인덱스에 위치

  - O(n+k)

    - 카운팅정렬(Counting)

      - 각 숫자각 몇번 등장했는지 세므로 숫자 크기에 시간복잡도가 매우 큰 영향을 받음
      - counting array를 누적합을 바꾸고 input array를의 값들을 out array에서 counting array의 인덱스에 넣음

  - O(nlogn)

    - 퀵정렬(Quick)

      - 기준점(pivot)을 정하여 작다면 좌측(left), 크다면 우측(right)에 정렬
      - 좌/우측으로 1차 정렬된 데이터에서 좌/우측 각각 정렬 수행
      - 재귀함수를 이용하여 반복

    - 병합정렬(Merge)

      - 분할 정복 알고리즘을 기반한 정렬
      - 재귀함수 사용
      - 리스트를 절반으로 잘라 비슷한 크기의 두 리스트로 나눔
      - 각 부분 리스트를 재귀적으로 병합정렬
      - 두 부분 리스트를 다시 병합

- 탐색(Search)

  - 순차탐색(Sequential)

    - 앞에서부터 하나씩 찾음

  - 이진탐색(Binary)

    - 정렬된 데이터에 사용
    - 반으로 나누어 다음 검색 위치를 결정

- 그래프(Graph)

  - 너비우선탐색(BFS)

    - 같은 레벨에 있는 형제 노드를 먼저 탐색

  - 깊이우선탐색(DFS)

    - 자식노드를 먼저 탐색

  - 최단경로 알고리즘(Shortest Path Algorithm)

    - 두 노드를 잇는 가장 짧은 경로를 찾는 알고리즘
    - 간선(edge)의 가중치 합이 최소인 경로를 찾음
    - 단일출발, 단일출발 및 단일도착, 전체 쌍

    - 다익스트라 알고리즘(Digikstra Algorithm)

      - 최단경로 알고리즘의 단일출발에 해당
      - 첫 정점을 기준으로 연결되어 있는 인접노드를 추가해가며 최단거리를 갱신

  - 최소신장트리 알고리즘(Minimum Spanning Tree)

    - 신장트리

      - 모든 노드가 연결되어 있고, 사이클이 없는 그래프

    - 최소신장트리

      - 간선의 가중치 합이 가장 작은 경로로 이루어진 신장트리

    - 크루스칼 알고리즘(Kruskal's Algorithm)

      - 탐욕 알고리즘을 기반
      - 모든 간선의 가중치를 오름차순으로 정렬
      - 가장 낮은 가중치를 갖는 간선부터 모든 노드를 연결하여 MST를 찾음
      - 사이클 유무는 Union-Find 알고리즘 사용

    - 프림 알고리즘(Prim's Algorithm)

      - 탐욕 알고리즘을 기반
      - 인접노드 중 간선의 가중치가 가장 작은 간선을 선택해 연결하여 MST를 찾음

    - 개선된 프림 알고리즘(Improved Prim's Algorithm)

      - 간선이 아닌 노드를 중심으로 우선순위 큐를 적용

- 문제해결전략(Problem Solving Strategy)

  - 재귀호출(Recursive Call)

    - 함수 안에서 해당 함수가 호출되는 형태
    - Stack처럼 동작

  - 동적계획법(Dynamic Programming)

    - 큰 문제를 작은 문제로 나누어 해결한 후, 작은 문제로 부터 계산된 결과값을 이용해 전체문제를 해결
    - 상향식 접근법
      - 가장 최하위 문제의 답을 구한 후, 상위 문제를 풀어나감
    - 메모이제이션(Memoization)
      - 중복되는 연산이 2번 수행되지 않도록 이전에 계산한 값을 저장
    - 중복 연산을 제거하고 재활용하여 전체적인 코드의 수행 및 연산 효율을 증대

  - 분할정복(Divide & Conquer)

    - 하위문제를 해결하고 다시 병합하여 상위문제의 답을 얻는 방식
    - 하향식 접근법
      - 아래로 내려가면서 하위문제의 해답을 먼저 구하는 방식
      - 재귀함수
    - DP와 차이
      - 나누어진 부분문제에 중복이 없음
      - 하향식 접근법을 사용
      - 메모이제이션 기법을 사용하지 않음

  - 탐욕 알고리즘(Greedy Algorithm)

    - 매순간 최선, 최적의 선택을 하여 최종적인 값을 구하는 방식

  - 백트래킹(Backtracking)

    - 제약조건 만족 문제(Constaint Satisfaction Problem)에서 해를 찾기 위한 전략
    - 후보군을 대상으로 제약조건을 체크하다 만족할 수 없다고 판단되면 다른 후보군으로 넘어가는 방식
