- RDB에서는 외래 키를 사용하여 서로 다른 테이블 간의 관계를 만들 수 있음

- 1:1
    - One-to-one relationships
    - 한테이블의 레코드 하나가 다른 테이블의 레코드 단 한 개와 관련된 경우
    - `OneToOneField()`
- N:1
    - Many-to-one relationships
    - 한 테이블의 0개 이상의 레코드가 다른 테이블의 레코드 한 개와 관련된 경우
    - `ForeignKey()`
- M:N
    - Many-to-many relationships
    - 한 테이블의 0개 이상의 레코드가 다른 테이블의 0개 이상의 레코드와 관련된 경우
    - `ManyToManyField()`

- Foreign Key
    - 외래 키(외부 키)
    - 다른 테이블의 행을 식별할 수 있는 키
    - 참조 무결성
        - 관련된 2개의 테이블 간의 일관성
    - `ForeignKey(to, on_delete, **options)`
        - 2개의 필수 위치 인자 필요
            1. 참조하는 `model class`
            2. `on_delete`옵션
                - 외래 키가 참조하는 객체가 사라졌을 때, 외래 키를 가진 객체를 어떻게 처리할 지를 정의
                - 데이터 무결성을 위해서중요
                    1. 개체 무결성(Entity integrity)
                    2. 참조 무결성(Referential integrity)
                    3. 범위 무결성(Domain integrity)
                    - [참조](https://en.wikipedia.org/wiki/Data_integrity)
                - `CASCADE`
                    - 부모 객체가 삭제 됐을 때 이를 참조하는 객체도삭제
                - `PROTECT`, `SET_NULL`, `SET_DEFAULT` 등 여러 옵션 값들이 존재
        - [docs](https://docs.djangoproject.com/en/3.2/ref/models/fields/#foreignkey)

- Comment - Article
    - 0개 이상의 댓글은 1개의 게시글에 작성 될 수 있음
    - Comment 모델 정의
        - `article = models.ForeignKey(Article, on_delete=models.CASCADE)`
        - 외래 키 필드는 작성하는 위치와 관계없이 필드의 마지막에 작성됨
        - ForeignKey()클래스의 인스턴스 이름은 참조하는 모델 클래스 이름의 단수형(소문자)으로 작성하는 것을 권장
            - migrate 후 article_id란 이름의 컬럼이 작성됨
    - 관계 모델 참조
        - Related manager
        - 역참조할 때에 사용할 수 있는 manager 생성
            - 이를 통해 objects처럼 queryset api를 사용할 수 있음
        - [docs](https://docs.djangoproject.com/en/3.2/ref/models/relations/)
        - `article.comment_set.method()`
            - 역참조 할 수 있는 comment_set manager를 자동으로 생성해 댓글 객체를 참조
            - `related_name='comments'`
                - ForeignKey arguments
                - 역참조 시 사용하는 매니저 이름을 변경
    - admin site 등록
    - CommentForm 작성
        - article은 사용자의 입력으로 받는 것이 아니라 view 함수 내에서 받아 별도로 처리되어 저장되어야 함
        - Meta에 `exclude = ('article',)`
    - detail
        - views
            - `comment_form = CommentForm()`, context에 추가
            - `comments = article.comment_set.all()`, context에 추가
        - 템플릿
            - comments_create로 보내는 form 내부에 `{{ comment_form }}`
            - for 문으로 comments안에 comment를 출력
                - for문 밖에 ul 태그, comment에 li 태그로 리스트 형식으로 출력 가능
                - comments_delete로 보내는 form
    - comments_create
        - url
            - `'<int:pk>/comments/'`
        - views
            ```python
            def comments_create(request, pk):
                article = Article.objects.get(pk=pk)
                comment_form = CommentForm(request.POST)
                if comment_form.is_valid():
                    comment = comment_form.save(commit=False)
                    comment.article = article
                    comment.save()
                return redirect('articles:detail', article.pk)
            ```
            - `save(commit=False)`
                - 데이터베이스에 저장되지 않은 인스턴스를 반환
                - [docs](https://docs.djangoproject.com/en/3.2/topics/forms/modelforms/#the-save-method)
    - comments_delete
        - url
            - `'<int:article_pk>/comments/<int:comment_pk>/delete/'`
        - views
            ```python
            def comments_delete(request, article_pk, comment_pk):
                comment = Comment.objects.get(pk=cpmment_pk)
                comment.delete()
                return redirect('articles:detail', article_pk)
            ```
    - 댓글 수정
        - 일반적으로 댓글 수정은 수정 페이지로 이동 없이 페이지가 유지된 상태로 수정함
        - 이는 JavaScript의 영역이기 때문에 이후에 별도로 진행
    - 추가 사항
        - 댓글 개수 출력하기
            1. DTL filter
                - `{{ comments|length }}`
                - `{{ article.comment_set.all|length }}`
            2. Queryset API
                - `{{ comments.count }}`
                - `{{ article.comment_set.count }}`
        - 댓글이 없는 경우 출력
            - DTL `for empty`
                - for와 endfor 사이에 `{% empty %}`

- Article - User
    - 0개 이상의 게시글은 1개의 회원에 의해 작성 될 수 있음
    - User 모델 참조 방법
        1. `settings.AUTH_USER_MODEL`
            - 'accounts.User'(문자열) 반환
            - models.py의 모델 필드에서 User 모델을 참조할 때 사용
        2. `get_user_model()`
            - User Object(객체) 반환
            - models.py가 아닌 다른 모든 곳에서 유저 모델을 참조할 때 사용
    - 모델 관계 설정
        - `user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)`
            - `from django.conf import settings`
        - makemigrations시 user_id의 기본값을 설정해 주어야 함
    - forms
        - ArticleForm의 Meta에 `fields = ('title', 'content',)`
            - ArticleForm에서 User는 form에서 제외해야 함
    - views
        - create
            - `commit=False`를 통해 저장하기 전에 `article.user = request.user` 이후 save
        - delete
            - `if request.user == article.user:`를 통해 작성자만 삭제 가능하도록 함
        - update
            - 위와 마찬가지
    - 템플릿
        - 위와 마찬가지로 `{% if request.user == article.user %}`를 통해 UPDATE와 DELETE 버튼을 작성자만 볼 수 있도록 함
        - `{{ article.user }}`로 작성자 출력

- Comment - User
    - 0개 이상의 댓글은 1개의 회원에 의해 작성 될 수 있음
    - 사실상 Article과 같음

- 인증된 사용자에 대한 접근 제한
    - views의 comment_create와 comment_delete에 `@require_POST`데코레이터와 `if request.user.is_authenticated:`문 추가
    - `{% if request.user.is_authenticated %}`를 통해 비인증 사용자는 CommentForm을 볼 수 없도록 함
        - `{% else %}`를 통해 로그인을 하도록 할 수도 있음