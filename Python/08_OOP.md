- 객체 지향 프로그래밍
- Object-Oriented Programming (OOP)
- 지금까지 해온 코딩은 사실상 절차 지향 프로그래밍
- 장점
    - **필요한 부분만 수정하기 쉽기 때문에 프로그램의 유지보수가 쉬움**
    - 클래스 단위로 모듈화 시켜 개발 할 수 있으므로 많은 인원이 참여하는 대규모 소프트웨어 개발에 적합
- 단점
    - 상호 작용 구조를 설계하기 위해 많은 노력과 시간이 필요
    - 상대적으로 느림

# 객체

- 속성(Attribute)과 기능(Method)으로 구성된 모든 것
- 객체(object)는 특정 타입의 인스턴스(instance)이다.
- 타입(type)
    - 어떤 연산자(operator)와 조작(method)이 가능한가?
- 속성(attribute)
    - 어떤 상태(데이터)를 가지는가?
- 조작법(method)
    - 어떤 행위(함수)를 할 수 있는가?

# 객체와 클래스 문법

- 클래스 정의
    - `class MyClass:`
- 인스턴스 생성
    - `my_instance = MyClass()`
- 메서드 호출
    - `my_instance.my_method()`
- 속성
    - `my_instance.my_attribute`
- 객체 비교
    - `==`
        - 동등(equal)
        - 객체가 동등한 경우 True
    - `is`
        - 동일(identical)
        - 동일한 객체를 가리키는 경우 True
- class 이름은 단어마다 대문자로 시작 (PascalCase로 약속)
    - ex. MyClass

# OOP 속성 (변수)

- 특정 데이터 타입/클래스의 객체들이 가지게 될 상태/데이터를 의미

## 인스턴스 변수

- 인스턴스가 개인적으로 가지고 있는 속성(attribute)
- 각 인스턴스들의 고유한 변수
- 생성자 메서드 `__init__`에서 `self.<name>`으로 정의
- 인스턴스가 생성된 이후 `<instance>.<name>`으로 접근 및 할당

## 클래스 변수

- 한 클래스의 모든 인스턴스가 공유하는 값
- 클래스 선언 내부에서 정의
- `<classname>.<name>`으로 접근 및 할당
- ex. 사용자 수 계산 등에 사용 (`__init__`될 때 `<classname>.count += 1`)
- `<instance>.<name>`으로 접근 및 할당하면 새로운 인스턴스 변수가 생성됨

# OOP 메서드 (함수)

- 특정 데이터 타입/클래스의 객체에 공통적으로 적용 가능한 행위(함수)

## 인스턴스 메서드(Instance Methods)

- 인스턴스 변수를 사용하거나, 인스턴스 변수에 값을 설정하는 메서드
- 클래스 변수도 사용 가능
- 클래스 내부에 정의되는 메서드의 기본
- 호출 시, 첫번째 인자로 인스터 자기자신 `self`가 전달됨
- `self`
    - 인스턴스 자기자신
    - 파이썬에서 인스턴스 메서드는 호출 시 첫번째 인자를 자신이 전달되도록 설계
    - 암묵적 규칙으로 `self`를 사용

### 매직 메서드

- 던더 `__`가 있는 메서드는 특수한 동작을 위해 만들어진 메서드
- 특정 상황에서 자동으로 불리는 메서드
- `__init__`
    - 생성자(constructor) 메서드
    - 인스턴스 객체 생성시 자동으로 호출되는 메서드
    - 인스턴스 변수들의 초기값 설정
- `__del__`
    - 인스턴스 객체가 소멸되기 직전에 호출되는 메서드
- `__str__`
    - 해당 객체의 출력 형태를 지정
    - 프린트 함수를 호출할 때, 자동으로 호출
- `__repr__`
    - 인스턴스 자체가 반환할 값을 반환
- `__gt__`, `__lt__`, `__ge__`, `__le__`, `__eq__`, `__ne__` 등
    - 연산자에 대한 메서드도 존재
    - 각각 `>`, `<`, `>=`, `<=`, `==`, `!=`

## 클래스 메서드(Class Methods)

- 클래스가 사용할 메서드
- 클래스 변수를 사용, 인스턴스 변수 사용은 불가능
- `@classmethod` 데코레이터를 사용하여 정의
- 호출 시, 첫번째 인자로 클래스 `cls`가 전달됨

## 정적 메서드(Static Methods)

- 인스턴스 변수, 클래스 변수 둘다 다루지 않는 메서드
- 속성을 다루지 않고 기능만을 하는 메서드를 정의할 때 사용
- `@staticmethod` 데코레이터를 사용하여 정의


## 메서드 정리 및 기타

- 인스턴스와 클래스는 3가지 메서드 모두에 접근할 수 있습니다.
- 인스턴스에서 클래스 메서드와 스태틱 메서드는 호출하지 않습니다. (가능하다 != 사용한다)
- 클래스에서 인스턴스 메서드는 호출하지 않습니다. (가능하다 != 사용한다)
- 클래스 자체(cls)와 그 속성에 접근할 필요가 있다면 클래스 메서드로 정의합니다.
 - 클래스와 클래스 속성에 접근할 필요가 없다면 정적 메서드로 정의합니다.
    - 정적 메서드는 cls, self와 같이 묵시적인 첫번째 인자를 받지 않기 때문입니다.

### 데코레이터

- 함수를 어떤 함수로 꾸며서 새로운 기능을 부여
- `@데코레이터(함수명)` 형태로 함수 위에 작성

### 이름 공간(namespace)

- 특정 속성에 접근하면, 인스턴스-클래스(자식클래스-부모클래스) 순으로 탐색

# 객체지향의 핵심개념

## 추상화

- 복잡한 것은 숨기고, 필요한 것만 들어내기

## 상속

- 두 클래스 사이 부모-자식 관계를 정립하는 것
- DRY
    - Don't Repeat Yourself
- `isinstance(object, classinfo)`
    - object가 classinfo의 instance이면 True
    - subclass인 경우에도 True
- `issubclass(class, classinfo)`
    - class가 classinfo의 subclass면 True
- `super()`
    - 자식클래스에서 부모클래스를 사용하는 경우
    - 보통 `__init__`에서 많이 사용
- 다중 상속
    - 두 개 이상의 클래스를 상속 받는 경우
    - 중복된 속성이나 메서드에 관해서는 상속 순서를 우선순위로 결정됨
- mro 메서드(Method Resolution Order)
    - `<classname>.mro()`
    - 해당 인스턴스의 클래스가 어떤 부모 클래스를 가지는지 확인하는 메서드

## 다형성

- 동일한 메서드가 클래스에 따라 다르게 행동할 수 있음
- 메서드 오버라이딩
    - 상속받은 메서드를 재정의
    - 부모 클래스의 메서드를 실행하고 싶은 경우 `super()`를 활용
- 오버로딩은 파이썬에서 정식으로 지원하지는 않음

## 캡슐화

- 객체의 일부 구현 내용에 대해 외부로부터의 직접적인 액세스를 차단
- 모든 내용이 캡슐 안에 존재한다
- Public Member
    - 언더바 없이 시작하는 메서드나 속성
    - 어디서나 호출, override 허용
- Protected Member
    - 언더바 1개로 시작하는 메서드나 속성
    - 부모클래스 내부와 자식클래스에서만 호출 가능 (암묵적 규칙)
    - override 허용
- Private Member
    - 언더바 2개로 시작하는 메서드나 속성
    - 본 클래스 내부에서만 사용 가능
    - 하위클래스 상속 및 호출 불가능
    - 외부 호출 불가능
- getter와 setter 메서드
    - getter 메서드
        - 변수의 값을 읽는 메서드
        - `@property` 데코레이터 사용
    - setter 메서드
        - 변수의 값을 설정하는 성격의 메서드
        - `@변수.setter` 데코레이터 사용
    - 두 메서드를 하나처럼 사용
    - [자세히 보기](https://www.daleseo.com/python-property/)