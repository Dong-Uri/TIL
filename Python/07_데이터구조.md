- 메서드(method)
    - 클래스 내부에 정의한 함수
    - 객체의 기능
- 파이썬 공식 문서의 표기법
    - `str.replace(old,new[,count])`
    - old,new는 필수, counut는 선택적 인자

# 문자열(String Type)

- 변경 불가능(immutable)
- `s.find(x)`
    - x의 첫 번째 위치를 반환
    - 없으면 -1을 반환
        - 오류가 나지 않음
- `s.index(x)`
    - x의 첫 번째 위치를 반환
    - 없으면 오류 발생
- `s.startswith(x), s.endswith(x)`
    - 문자열이 x로 시작하거나, 끝나는가?
- `s.isalpha()`
    - 글자로 이루어져 있는가? (숫자 X)
- `s.isspace()`
    - 공백으로 이루어져 있는가?
- `s.isupper(), s.islower()`
    - 대문자, 소문자로 이루어져 있는가?
- `s.istitle()`
    - 타이틀 형식으로 이루어져 있는가?
- `s.isdecimal() < s.isdigit() < s.isnumeric()`
    - 문자열이 0~9의 숫자로 이루어져 있는가?
    - 문자열이 숫자로 이루어져 있는가?
    - 문자열을수로 볼 수 있는가?
    - 예시를 암기할 필요가 있는가?
        - **없음**
- `s.replace(old,new[,count])`
    - old를 new로 count만큼 바꿔서 반환
    - count를 지정하지 않으면 모두
- `s.strip([chars])`
    - 양쪽에 붙어있는 특정한 문자들을 제거
    - chars를 지정하지 않으면 공백을 제거
    - `s.lstrip([chars]), s.rstrip([chars])`
        - 문자열을 왼쪽, 오른쪽에서 제거
- `s.split(sep=None, maxsplit=-1)`
    - 문자열을 특정한 단위로 나누어 리스트로 반환
    - sep이 저정되지 않으면 공백문자에 대해 나눔
    - maxsplit이 -1이면 제한 없음
- `'separator'.join(iterable)`
    - 반대로 iterable을 separator(구분자)로 이어붙인 문자열을 반환
    - 순서 주의할 것
- `s.capitalize()`
    - 첫글자를 대문자로
- `s.title()`
    - 어포스트로피(')나 공백 이후 문자를 대문자로, 나머지는 소문자로
- `s.upper(), s.lower()`
    - 모두 대문자, 소문자로
- `s.swapcase()`
    - 대문자는 소문자로, 소문자는 대문자로

# 리스트(List)

- 가변 자료형(mutable)
    - 생성 이후 내용 변경이 가능
- 인덱스를 통해 접근 가능
- `L.append(x)`
    - 리스트 마지막에 x를 추가
- `L.extend(iterable)`
    - 리스트에 iterable의 항목을 추가
    - 문자열을 넣으면 각 문자가 따로 추가됨
- `L.insert(i,x)`
    - i위치에 x를 추가
    - i가 리스트 길이보다 큰 경우 맨 뒤에 추가
- `L.pop([i])`
    - i위치에 있는 값 삭제
    - 동시에 그 항목을 반환
    - i를 지정하지 않으면 마지막 항목
- `L.clear()`
    - 모두 삭제
- `L.remove(x)`
    - 값이 x인 첫번째 항목 삭제
    - x가 없는 경우 `ValueError`
- `L.index(x[,start[,end]])`
    - x를 찾아 해당 index를 반환
    - x가 없는 경우 `ValueError`
    - 시작이나 시작과 끝을 지정 가능
- `L.count(x)`
    - x를 찾아 개수를 반환
    - x가 없는 경우 0
- `L.sort()`
    - 리스트를 정렬
    - **원본 list를 변형** 시키고, None을 반환
    - `sorted(L)`
        - 원본 list는 그대로인채, 정렬된 list를 반환
- `L.reverse()`
    - 리스트를 역순으로 뒤집음
    - **원본 list를 변형** 시키고, None을 반환
    - `reversed(L)`
        - 원본 list는 그대로인채, 뒤집힌 list를 반환

# 튜플(Tuple)

- 변경 불가능(immutable)
    - 값에 영향을 미치지 않는 메서드만을 지원'
- 리스트 메서드와 대부분 동일
    - 항목을 변경하는 메서드들 제외
- `t.index(x[,start[,end]])`
    - x를 찾아 해당 index를 반환
    - x가 없는 경우 `ValueError`
    - 시작이나 시작과 끝을 지정 가능
- `t.count(x)`
    - x를 찾아 개수를 반환
    - x가 없는 경우 0

# 연산자(Operator)

- 멤버십 연산자(Membership Operator)
    - 포함 여부 확인
        - `in`
        - `not in`
- 시퀀스형 연산자(Sequence Type Operator)
    - 산술연산자 `+`
        - 시퀀스 간의 concatenation(연결/연쇄)
    - 반복연산자 `*`
        - 시퀀스를 반복
    - 둘 다 range는 불가

# 셋(Set)

- 가변 자료형(mutable)
    - 요소를 삽입, 변경, 삭제 가능
- 중복을 허용하지 않음
- 순서가 없어 인덱스로 접근 불가능
- `s.add(elem)`
    - elem을 셋에 추가
- `s.update(*others)`
    - iterable을 셋에 추가
- `s.remove(elem)`
    - elem을 셋에서 삭제
    - elem이 없으면 `KeyError`
- `s.discard(elem)`
    - elem을 셋에서 삭제    
    - elem이 없어도 에러가 발생하지 않음
- `s.pop()`
    - 임의의 원소를 제거
    - 동시에 그 원소를 반환
    - 셋이 비어있으면 `KeyError`
- `s.clear()`
    - 모두 제거
- `s.copy()`
    - 얕은 복사
- `s.isdisjoint(t)`
    - s와 t가 서로소이면 True
        - 서로 같은 항목을 하나도 갖고 있지 않은 경우
- `s.issubset(t)`
    - s가 t의 하위 셋이면 True
- `s.issuperset(t)`
    - s가 t의 상위 셋이면 True

# 딕셔너리(Dictionary)

- `d.get(key[,default])`
    - key에 대한 value를 반환
    - key가 없어도 `KeyError`가 발생하지 않고, default 값을 반환
        - default의 기본값은 None
- `d.setdefault(key[,default])`
    - get과 비슷한 동작을 함
    - key가 없는 경우 default 값을 갖는 key를 삽입함
        - default의 기본값도 똑같이 None
- `d.pop(key[,default])`
    - key를 찾아 제거한 후, key에 대한 value를 반환
    - key가 없으면 default 값을 반환
        - default가 없을때는 `KeyError` 발생
- `d.update([other])`
    - other가 주는 key, value 쌍으로 딕셔너리를 덮어씀
        - 없으면 추가, 있으면 수정
- `d.clear()`
    - 모두 제거
- `d.copy()`
    - 얕은 복사
- `d.keys(), d.values(), d.items()`
    - d의 모든 키, 모든 값, 모든 키-값의 쌍 반환

# 얕은 복사와 깊은 복사(Shallow Copy & Deep Copy)

- 할당(Assignment)
    - 대입 연산자 `=`
        - `copy_list = original_list`
        - 해당 객체에 대한 객체 참조를 복사
        - 해당 주소의 일부 값을 변경하는 경우 이를 참조하는 모든 변수에 영향
- 얕은 복사(shallow copy)
    - Slice 연산자 활용
        - `b = a[:]`
        - 연결된 결과를 복사
            - 다른 주소
        - 복사한 리스트의 원소가 주소를 참조하는 경우 이를 참조하는 모든 변수에 영향
- 깊은 복사(Deep copy)
    - `import copy`
    - `b = copy.deepcopy(a)`
